declare module BABYLON {
    class EngineCapabilities {
        public maxTexturesImageUnits: number;
        public maxTextureSize: number;
        public maxCubemapTextureSize: number;
        public maxRenderTextureSize: number;
        public standardDerivatives: boolean;
        public s3tc: any;
        public textureFloat: boolean;
        public textureAnisotropicFilterExtension: any;
        public maxAnisotropy: number;
    }
    class Engine {
        static ShadersRepository: string;
        static ALPHA_DISABLE: number;
        static ALPHA_ADD: number;
        static ALPHA_COMBINE: number;
        static DELAYLOADSTATE_NONE: number;
        static DELAYLOADSTATE_LOADED: number;
        static DELAYLOADSTATE_LOADING: number;
        static DELAYLOADSTATE_NOTLOADED: number;
        static Epsilon: number;
        static CollisionsEpsilon: number;
        public isFullscreen: boolean;
        public isPointerLock: boolean;
        public forceWireframe: boolean;
        public cullBackFaces: boolean;
        public renderEvenInBackground: boolean;
        public scenes: Scene[];
        private _gl;
        private _renderingCanvas;
        private _windowIsBackground;
        private _onBlur;
        private _onFocus;
        private _onFullscreenChange;
        private _onPointerLockChange;
        private _hardwareScalingLevel;
        private _caps;
        private _pointerLockRequested;
        private _alphaTest;
        private _runningLoop;
        private _renderFunction;
        private _loadedTexturesCache;
        public _activeTexturesCache: Texture[];
        private _currentEffect;
        private _cullingState;
        private _compiledEffects;
        private _lastVertexAttribIndex;
        private _depthMask;
        private _cachedViewport;
        private _cachedVertexBuffers;
        private _cachedIndexBuffer;
        private _cachedEffectForVertexBuffers;
        private _currentRenderTarget;
        private _workingCanvas;
        private _workingContext;
        constructor(canvas: HTMLCanvasElement, antialias?: boolean, options?: any);
        public getAspectRatio(camera: Camera): number;
        public getRenderWidth(): number;
        public getRenderHeight(): number;
        public getRenderingCanvas(): HTMLCanvasElement;
        public setHardwareScalingLevel(level: number): void;
        public getHardwareScalingLevel(): number;
        public getLoadedTexturesCache(): WebGLTexture[];
        public getCaps(): EngineCapabilities;
        public setDepthFunctionToGreater(): void;
        public setDepthFunctionToGreaterOrEqual(): void;
        public setDepthFunctionToLess(): void;
        public setDepthFunctionToLessOrEqual(): void;
        public stopRenderLoop(): void;
        public _renderLoop(): void;
        public runRenderLoop(renderFunction: () => void): void;
        public switchFullscreen(requestPointerLock: boolean): void;
        public clear(color: any, backBuffer: boolean, depthStencil: boolean): void;
        public setViewport(viewport: Viewport, requiredWidth?: number, requiredHeight?: number): void;
        public setDirectViewport(x: number, y: number, width: number, height: number): void;
        public beginFrame(): void;
        public endFrame(): void;
        public resize(): void;
        public bindFramebuffer(texture: WebGLTexture): void;
        public unBindFramebuffer(texture: WebGLTexture): void;
        public flushFramebuffer(): void;
        public restoreDefaultFramebuffer(): void;
        public createVertexBuffer(vertices: number[]): WebGLBuffer;
        public createDynamicVertexBuffer(capacity: number): WebGLBuffer;
        public updateDynamicVertexBuffer(vertexBuffer: WebGLBuffer, vertices: any, length?: number): void;
        public createIndexBuffer(indices: number[]): WebGLBuffer;
        public bindBuffers(vertexBuffer: WebGLBuffer, indexBuffer: WebGLBuffer, vertexDeclaration: number[], vertexStrideSize: number, effect: Effect): void;
        public bindMultiBuffers(vertexBuffers: VertexBuffer[], indexBuffer: WebGLBuffer, effect: Effect): void;
        public _releaseBuffer(buffer: WebGLBuffer): void;
        public draw(useTriangles: boolean, indexStart: number, indexCount: number): void;
        public _releaseEffect(effect: Effect): void;
        public createEffect(baseName: any, attributesNames: string[], uniformsNames: string[], samplers: string[], defines: string, optionalDefines?: string[], onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): Effect;
        public createShaderProgram(vertexCode: string, fragmentCode: string, defines: string): WebGLProgram;
        public getUniforms(shaderProgram: WebGLProgram, uniformsNames: string[]): WebGLUniformLocation[];
        public getAttributes(shaderProgram: WebGLProgram, attributesNames: string[]): number[];
        public enableEffect(effect: Effect): void;
        public setArray(uniform: WebGLUniformLocation, array: number[]): void;
        public setMatrices(uniform: WebGLUniformLocation, matrices: Float32Array): void;
        public setMatrix(uniform: WebGLUniformLocation, matrix: Matrix): void;
        public setFloat(uniform: WebGLUniformLocation, value: number): void;
        public setFloat2(uniform: WebGLUniformLocation, x: number, y: number): void;
        public setFloat3(uniform: WebGLUniformLocation, x: number, y: number, z: number): void;
        public setBool(uniform: WebGLUniformLocation, bool: number): void;
        public setFloat4(uniform: WebGLUniformLocation, x: number, y: number, z: number, w: number): void;
        public setColor3(uniform: WebGLUniformLocation, color3: Color3): void;
        public setColor4(uniform: WebGLUniformLocation, color3: Color3, alpha: number): void;
        public setState(culling: boolean): void;
        public setDepthBuffer(enable: boolean): void;
        public setDepthWrite(enable: boolean): void;
        public setColorWrite(enable: boolean): void;
        public setAlphaMode(mode: number): void;
        public setAlphaTesting(enable: boolean): void;
        public getAlphaTesting(): boolean;
        public wipeCaches(): void;
        public createTexture(url: string, noMipmap: boolean, invertY: boolean, scene: Scene): WebGLTexture;
        public createDynamicTexture(width: number, height: number, generateMipMaps: boolean): WebGLTexture;
        public updateDynamicTexture(texture: WebGLTexture, canvas: HTMLCanvasElement, invertY: boolean): void;
        public updateVideoTexture(texture: WebGLTexture, video: HTMLVideoElement, invertY: boolean): void;
        public createRenderTargetTexture(size: any, options: any): WebGLTexture;
        public createCubeTexture(rootUrl: string, scene: Scene, extensions: string[], noMipmap?: boolean): WebGLTexture;
        public _releaseTexture(texture: WebGLTexture): void;
        public bindSamplers(effect: Effect): void;
        public _bindTexture(channel: number, texture: WebGLTexture): void;
        public setTextureFromPostProcess(channel: number, postProcess: PostProcess): void;
        public setTexture(channel: number, texture: Texture): void;
        public _setAnisotropicLevel(key: number, texture: Texture): void;
        public readPixels(x: number, y: number, width: number, height: number): Uint8Array;
        public dispose(): void;
        static isSupported(): boolean;
    }
}
