declare module BABYLON {
    class Scene {
        static FOGMODE_NONE: number;
        static FOGMODE_EXP: number;
        static FOGMODE_EXP2: number;
        static FOGMODE_LINEAR: number;
        public autoClear: boolean;
        public clearColor: Color3;
        public ambientColor: Color3;
        public beforeRender: () => void;
        public afterRender: () => void;
        public forceWireframe: boolean;
        public clipPlane: Plane;
        private _onPointerMove;
        private _onPointerDown;
        public onPointerDown: (evt: PointerEvent, pickInfo: PickingInfo) => void;
        public fogMode: number;
        public fogColor: Color3;
        public fogDensity: number;
        public fogStart: number;
        public fogEnd: number;
        public lightsEnabled: boolean;
        public lights: Light[];
        public cameras: Camera[];
        public activeCameras: Camera[];
        public activeCamera: Camera;
        public meshes: Mesh[];
        public materials: Material[];
        public multiMaterials: MultiMaterial[];
        public defaultMaterial: StandardMaterial;
        public texturesEnabled: boolean;
        public textures: BaseTexture[];
        public particlesEnabled: boolean;
        public particleSystems: ParticleSystem[];
        public spriteManagers: SpriteManager[];
        public layers: Layer[];
        public skeletons: Skeleton[];
        public lensFlareSystems: LensFlareSystem[];
        public collisionsEnabled: boolean;
        public gravity: Vector3;
        public postProcessesEnabled: boolean;
        public postProcessManager: PostProcessManager;
        public renderTargetsEnabled: boolean;
        public customRenderTargets: RenderTargetTexture[];
        public useDelayedTextureLoading: boolean;
        public database: any;
        public actionManager: ActionManager;
        private _engine;
        private _totalVertices;
        public _activeVertices: number;
        public _activeParticles: number;
        private _lastFrameDuration;
        private _evaluateActiveMeshesDuration;
        private _renderTargetsDuration;
        public _particlesDuration: number;
        private _renderDuration;
        public _spritesDuration: number;
        private _animationRatio;
        private _animationStartDate;
        private _renderId;
        private _executeWhenReadyTimeoutId;
        public _toBeDisposed: SmartArray;
        private _onReadyCallbacks;
        private _pendingData;
        private _onBeforeRenderCallbacks;
        private _activeMeshes;
        private _processedMaterials;
        private _renderTargets;
        public _activeParticleSystems: SmartArray;
        private _activeSkeletons;
        private _renderingManager;
        private _physicsEngine;
        private _activeAnimatables;
        private _transformMatrix;
        private _pickWithRayInverseMatrix;
        private _scaledPosition;
        private _scaledVelocity;
        private _boundingBoxRenderer;
        private _viewMatrix;
        private _projectionMatrix;
        private _frustumPlanes;
        private _selectionOctree;
        private _pointerOverMesh;
        constructor(engine: Engine);
        public getBoundingBoxRenderer(): BoundingBoxRenderer;
        public getEngine(): Engine;
        public getTotalVertices(): number;
        public getActiveVertices(): number;
        public getActiveParticles(): number;
        public getLastFrameDuration(): number;
        public getEvaluateActiveMeshesDuration(): number;
        public getActiveMeshes(): SmartArray;
        public getRenderTargetsDuration(): number;
        public getRenderDuration(): number;
        public getParticlesDuration(): number;
        public getSpritesDuration(): number;
        public getAnimationRatio(): number;
        public getRenderId(): number;
        public attachControl(): void;
        public detachControl(): void;
        public isReady(): boolean;
        public registerBeforeRender(func: () => void): void;
        public unregisterBeforeRender(func: () => void): void;
        public _addPendingData(data: any): void;
        public _removePendingData(data: any): void;
        public getWaitingItemsCount(): number;
        public executeWhenReady(func: () => void): void;
        public _checkIsReady(): void;
        public beginAnimation(target: any, from: number, to: number, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void): void;
        public beginDirectAnimation(target: any, animations: Animation[], from: number, to: number, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void): void;
        public stopAnimation(target: any): void;
        private _animate();
        public getViewMatrix(): Matrix;
        public getProjectionMatrix(): Matrix;
        public getTransformMatrix(): Matrix;
        public setTransformMatrix(view: Matrix, projection: Matrix): void;
        public setActiveCameraByID(id: string): Camera;
        public setActiveCameraByName(name: string): Camera;
        public getMaterialByID(id: string): Material;
        public getMaterialByName(name: string): Material;
        public getCameraByID(id: string): Camera;
        public getCameraByName(name: string): Camera;
        public getLightByName(name: string): Light;
        public getLightByID(id: string): Light;
        public getMeshByID(id: string): Mesh;
        public getLastMeshByID(id: string): Mesh;
        public getLastEntryByID(id: string): Node;
        public getMeshByName(name: string): Mesh;
        public getLastSkeletonByID(id: string): Skeleton;
        public getSkeletonById(id: string): Skeleton;
        public getSkeletonByName(name: string): Skeleton;
        public isActiveMesh(mesh: Mesh): boolean;
        private _evaluateSubMesh(subMesh, mesh);
        private _evaluateActiveMeshes();
        public updateTransformMatrix(force?: boolean): void;
        private _renderForCamera(camera);
        private _processSubCameras(camera);
        public render(): void;
        public dispose(): void;
        public _getNewPosition(position: Vector3, velocity: Vector3, collider: Collider, maximumRetry: number, finalPosition: Vector3): void;
        private _collideWithWorld(position, velocity, collider, maximumRetry, finalPosition);
        public createOrUpdateSelectionOctree(): void;
        public createPickingRay(x: number, y: number, world: Matrix, camera: Camera): Ray;
        private _internalPick(rayFunction, predicate, fastCheck?);
        public pick(x: number, y: number, predicate?: (mesh: Mesh) => boolean, fastCheck?: boolean, camera?: Camera): PickingInfo;
        public pickWithRay(ray: Ray, predicate: (mesh: Mesh) => boolean, fastCheck?: boolean): PickingInfo;
        public setPointerOverMesh(mesh: Mesh): void;
        public getPointerOverMesh(): Mesh;
        public getPhysicsEngine(): PhysicsEngine;
        public enablePhysics(gravity: Vector3, plugin?: PhysicsEnginePlugin): boolean;
        public disablePhysicsEngine(): void;
        public isPhysicsEnabled(): boolean;
        public setGravity(gravity: Vector3): void;
        public createCompoundImpostor(parts: any, options: PhysicsBodyCreationOptions): any;
        public deleteCompoundImpostor(compound: any): void;
        private _getByTags(list, tagsQuery);
        public getMeshesByTags(tagsQuery: string): Mesh[];
        public getCamerasByTags(tagsQuery: string): Camera[];
        public getLightsByTags(tagsQuery: string): Light[];
        public getMaterialByTags(tagsQuery: string): Material[];
    }
}
