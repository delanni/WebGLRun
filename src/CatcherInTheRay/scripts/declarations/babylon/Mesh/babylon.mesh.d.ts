declare module BABYLON {
    class Mesh extends Node {
        static BILLBOARDMODE_NONE: number;
        static BILLBOARDMODE_X: number;
        static BILLBOARDMODE_Y: number;
        static BILLBOARDMODE_Z: number;
        static BILLBOARDMODE_ALL: number;
        public position: Vector3;
        public rotation: Vector3;
        public rotationQuaternion: any;
        public scaling: Vector3;
        public delayLoadState: number;
        public material: any;
        public isVisible: boolean;
        public isPickable: boolean;
        public visibility: number;
        public billboardMode: number;
        public checkCollisions: boolean;
        public receiveShadows: boolean;
        public _isDisposed: boolean;
        public onDispose: any;
        public skeleton: any;
        public renderingGroupId: number;
        public infiniteDistance: boolean;
        public showBoundingBox: boolean;
        public subMeshes: SubMesh[];
        public delayLoadingFile: string;
        public actionManager: ActionManager;
        private _positions;
        private _localScaling;
        private _localRotation;
        private _localTranslation;
        private _localBillboard;
        private _localPivotScaling;
        private _localPivotScalingRotation;
        private _localWorld;
        private _worldMatrix;
        private _rotateYByPI;
        private _collisionsTransformMatrix;
        private _collisionsScalingMatrix;
        private _absolutePosition;
        private _isDirty;
        public _physicImpostor: number;
        public _physicsMass: number;
        public _physicsFriction: number;
        public _physicRestitution: number;
        private _boundingInfo;
        private _totalVertices;
        private _pivotMatrix;
        private _indices;
        private _renderId;
        private _onBeforeRenderCallbacks;
        private _delayInfo;
        private _animationStarted;
        private _vertexBuffers;
        private _indexBuffer;
        private _delayLoadingFunction;
        constructor(name: string, scene: Scene);
        public getBoundingInfo(): BoundingInfo;
        public getWorldMatrix(): Matrix;
        public rotate(axis: Vector3, amount: number, space: Space): void;
        public translate(axis: Vector3, distance: number, space: Space): void;
        public getAbsolutePosition(): Vector3;
        public setAbsolutePosition(absolutePosition: Vector3): void;
        public getTotalVertices(): number;
        public getVerticesData(kind: any): number[];
        public getVertexBuffer(kind: any): VertexBuffer;
        public isVerticesDataPresent(kind: string): boolean;
        public getVerticesDataKinds(): string[];
        public getTotalIndices(): number;
        public getIndices(): number[];
        public setPivotMatrix(matrix: Matrix): void;
        public getPivotMatrix(): Matrix;
        public _isSynchronized(): boolean;
        public isReady(): boolean;
        public isAnimated(): boolean;
        public isDisposed(): boolean;
        public _initCache(): void;
        public markAsDirty(property: string): void;
        public refreshBoundingInfo(): void;
        public _updateBoundingInfo(): void;
        public computeWorldMatrix(force?: boolean): Matrix;
        public _createGlobalSubMesh(): SubMesh;
        public subdivide(count: number): void;
        public setVerticesData(data: number[], kind: string, updatable?: boolean): void;
        public updateVerticesData(kind: string, data: number[], updateExtends?: boolean): void;
        public setIndices(indices: number[]): void;
        public bindAndDraw(subMesh: SubMesh, effect: any, wireframe?: boolean): void;
        public registerBeforeRender(func: () => void): void;
        public unregisterBeforeRender(func: () => void): void;
        public render(subMesh: SubMesh): void;
        public getEmittedParticleSystems(): ParticleSystem[];
        public getHierarchyEmittedParticleSystems(): ParticleSystem[];
        public getChildren(): Node[];
        public isInFrustum(frustumPlanes: Plane[]): boolean;
        public setMaterialByID(id: string): void;
        public getAnimatables(): IAnimatable[];
        public setPositionWithLocalVector(vector3: Vector3): void;
        public getPositionExpressedInLocalSpace(): Vector3;
        public locallyTranslate(vector3: Vector3): void;
        public bakeTransformIntoVertices(transform: Matrix): void;
        public lookAt(targetPoint: Vector3, yawCor: number, pitchCor: number, rollCor: number): void;
        public _resetPointsArrayCache(): void;
        public _generatePointsArray(): void;
        public _collideForSubMesh(subMesh: SubMesh, transformMatrix: Matrix, collider: Collider): void;
        public _processCollisionsForSubModels(collider: Collider, transformMatrix: Matrix): void;
        public _checkCollision(collider: Collider): void;
        public intersectsMesh(mesh: Mesh, precise?: boolean): boolean;
        public intersectsPoint(point: Vector3): boolean;
        public intersects(ray: Ray, fastCheck?: boolean): PickingInfo;
        public clone(name: string, newParent: Node, doNotCloneChildren?: boolean): Mesh;
        public dispose(doNotRecurse?: boolean): void;
        public setPhysicsState(impostor?: any, options?: PhysicsBodyCreationOptions): void;
        public getPhysicsImpostor(): number;
        public getPhysicsMass(): number;
        public getPhysicsFriction(): number;
        public getPhysicsRestitution(): number;
        public applyImpulse(force: Vector3, contactPoint: Vector3): void;
        public setPhysicsLinkWith(otherMesh: Mesh, pivot1: Vector3, pivot2: Vector3): void;
        public convertToFlatShadedMesh(): void;
        static CreateBox(name: string, size: number, scene: Scene, updatable?: boolean): Mesh;
        static CreateSphere(name: string, segments: number, diameter: number, scene: Scene, updatable?: boolean): Mesh;
        static CreateCylinder(name: string, height: number, diameterTop: number, diameterBottom: number, tessellation: number, scene: Scene, updatable?: boolean): Mesh;
        static CreateTorus(name: string, diameter: any, thickness: number, tessellation: number, scene: Scene, updatable?: boolean): Mesh;
        static CreateTorusKnot(name: string, radius: number, tube: number, radialSegments: number, tubularSegments: number, p: number, q: number, scene: Scene, updatable?: boolean): Mesh;
        static CreatePlane(name: string, size: number, scene: Scene, updatable?: boolean): Mesh;
        static CreateGround(name: string, width: number, height: number, subdivisions: number, scene: Scene, updatable?: boolean): Mesh;
        static CreateGroundFromHeightMap(name: string, url: string, width: number, height: number, subdivisions: number, minHeight: number, maxHeight: number, scene: Scene, updatable?: boolean): Mesh;
        static CreateGroundFromHeightMapOfCanvas(name: string, canvas: HTMLCanvasElement, width: number, height: number, subdivisions: number, minHeight: number, maxHeight: number, scene: Scene, updatable?: boolean): Mesh;

        static MinMax(meshes: Mesh[]): {
            min: Vector3;
            max: Vector3;
        };
        static Center(meshesOrMinMaxVector: any): Vector3;
    }
}
