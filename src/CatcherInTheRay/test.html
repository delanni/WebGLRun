<!DOCTYPE html>
<html>
<head>
	<title>TESTING TERRAIN GEN</title>
</head>
<body bgcolor="lightskyblue">
<canvas id="canvas" width="480" height="640"></canvas>

<script type="text/javascript">
	this.W = 480;
	this.H = 640;

	this.c = document.getElementById("canvas");
	this.ctx = c.getContext("2d");

	ImageData.prototype.setPixel = function(x,y,r,g,b,a){
		if (typeof a == 'undefined') { a = 255};
		if (typeof g == 'undefined') { g = b = r};

		if(x>this.width || y>this.height) return false;

		var w =  this.width;
		var start = (w*(y|0)+(x|0)%w)*4;
		this.data[start] = r;
		this.data[start+1] = g;
		this.data[start+2] = b;
		this.data[start+3] = a;

		return true;
	}

	ImageData.prototype.getPixel = function(x,y){
		if(x>this.width || y>this.height) return false;

		var w =  this.width;
		var start = (w*(y|0)+(x|0)%w)*4;
		r= this.data[start] ;
		g = this.data[start+1];
		b = this.data[start+2];
		a = this.data[start+3];

		return [r,g,b,a];
	}

	ctx.clear = function(){
		ctx.save();
			ctx.fillStyle="white";
			ctx.fillRect(0,0,window.W,window.H);
		ctx.restore();
	}

	ctx.clear();

	ctx.input = function(array /*[[x,y,r,g,b,a],...]*/){
	
		var iData = this.getImageData(0,0,window.W,window.H);

		for(var x = 0; x<array.length; x++){
			if (!iData.setPixel.apply(iData,array[x])) console.log("FAKK");
		}

		this.putImageData(iData,0,0);
	}

</script>

<script type="text/javascript">
	function makePath(ctx,startX, endX){
		var STEP = 1;
		var CURVEFACTOR = 10;
		var steps = (window.H/STEP)|0;
		var startXY = [startX,window.H];
		var endXY = [endX,0];

		var dx =(endXY[0]-startXY[0])/steps;
		var dy =(endXY[1]-startXY[1])/steps;

		var normal = [-dy,dx];
		var m = Math.sqrt(Math.pow(normal[0],2)+Math.pow(normal[1],2));
		normal[0]/=m; normal[1]/=m;
		offset = 100;

		var lpast=0;
		var ipast = -80000;
		var points = [];
		var ctrlPoints = [];
		ctrlPoints.push(startXY);
		ctrlPoints.push(startXY);
		for(var i =0; i<steps; i++){
			points.push([startXY[0]+dx*i, startXY[1]+dy*i, 0]);
			if (Math.random()>0.90 && Math.abs(i-ipast)>10 && Math.abs(i-window.H)>10 && Math.abs(i)>10) {
				ipast=i;
				var l = Math.random()*offset - offset/2;
				if (Math.abs(l-lpast)>offset*0.5 && l*lpast<0) l*=-1;
				lpast = l;
				var offsetX =  normal[0]*l;
				var offsetY =  normal[1]*l;
				var p = [startXY[0]+dx*i +offsetX, startXY[1]+dy*i+offsetY];
				//ctx.beginPath();
				//ctx.moveTo(startXY[0]+dx*i, startXY[1]+dy*i);
				//ctx.lineTo(p[0],p[1]);
				//ctx.stroke();
				ctrlPoints.push(p);
			}

		}

		//ctx.input(points);

		ctrlPoints.push(points[points.length-1]);
		ctrlPoints.push(points[points.length-1]);

		//var cmspline = drawCatmull(ctrlPoints);
		var cmspline = makeCatmull(ctrlPoints);
		drawPath(cmspline);
	}

	var drawPath = function(points){
		ctx.moveTo(points[0][0],points[0][1]);
		ctx.beginPath();

		for(var j=0;j<points.length;j++)
			ctx.lineTo(points[j][0],points[j][1]);
			
		ctx.stroke();
	}

	c.onclick = function(e){
		var imgData = ctx.getImageData(0,0,window.W,window.H);
		var ref = imgData.getPixel(e.x,e.y);
		console.log(ref);
		floodFill(imgData,ref,e.x,e.y);
		ctx.putImageData(imgData,0,0);
	}

/*	function flood(imgData,refColor,x,y){
		if (x>0&&x<imgData.width&&y>0&&y<imgData.height){
			var pxCol = imgData.getPixel(x,y);
			if(pxCol[0]==refColor[0] &&pxCol[1]==refColor[1] &&pxCol[2]==refColor[2] && pxCol[3]==refColor[3]){
				imgData.setPixel(x,y,255,0,0,0);
				flood(imgData,refColor,x+1,y);
				flood(imgData,refColor,x-1,y);
				flood(imgData,refColor,x,y+1);
				flood(imgData,refColor,x,y-1);
			}
		}
		return imgData;
	}
*/

	//http://stackoverflow.com/questions/2106995/how-can-i-perform-flood-fill-with-html-canvas
	function floodFill(imgData, refColor, x, y) {
		var ctx, minChangedX, minChangedY, maxChangedX, maxChangedY, wasTested, shouldTest, imageData, pixels, currentX, currentY, currentColor, currentIndex, seedColor, tryX, tryY, tryIndex, boundsWidth, boundsHeight, pixelStart, fillRed, fillGreen, fillBlue, fillAlpha;
    
        fillColor = {r:255,g:0,b:0,a:255}
    
	    x = x|0;
	    y = y|0;
	    
	    bounds = { x: 0, y: 0, width: imgData.width, height: imgData.height };
	    
	    stopFunction = function(seedColor, pixelColor) {
	        return pixelColor.r != seedColor.r || pixelColor.g != seedColor.g || pixelColor.b != seedColor.b || pixelColor.a != seedColor.a;
	    }
	    
	    minChangedX = maxChangedX = x - bounds.x;
	    minChangedY = maxChangedY = y - bounds.y;
	    boundsWidth = bounds.width;
	    boundsHeight = bounds.height;

	    // Initialize wasTested to false. As we check each pixel to decide if it should be painted with the new color,
	    // we will mark it with a true value at wasTested[row = y][column = x];
	    wasTested = new Array(boundsHeight * boundsWidth);
	    /*
	    $R(0, bounds.height - 1).each(function (row) { 
	      var subArray = new Array(bounds.width);
	      wasTested[row] = subArray;
	    });
	    */

	    // Start with a single point that we know we should test: (x, y). 
	    // Convert (x,y) to image data coordinates by subtracting the bounds' origin.
	    currentX = x - bounds.x;
	    currentY = y - bounds.y;
	    currentIndex = currentY * boundsWidth + currentX;
	    shouldTest = [ currentIndex ];

	    pixels = imgData.data;
	    seedColor = {r:refColor[0],g:refColor[1],b:refColor[2],a:refColor[3]};
	    currentColor = { r: 0, g: 0, b: 0, a: 1 };
	    fillRed = fillColor.r;
	    fillGreen = fillColor.g;
	    fillBlue = fillColor.b;
	    fillAlpha = fillColor.a;
	    while (shouldTest.length > 0) {
	      currentIndex = shouldTest.pop();
	      currentX = currentIndex % boundsWidth;
	      currentY = (currentIndex - currentX) / boundsWidth;
	      if (! wasTested[currentIndex]) {
	        wasTested[currentIndex] = true;
	        //currentColor = ImageProcessing.getColor(pixels, currentX, currentY, boundsWidth, boundsHeight, currentColor);
	        // Inline getColor for performance.
	        pixelStart = currentIndex * 4;
	        currentColor.r = pixels[pixelStart];
	        currentColor.g = pixels[pixelStart + 1]
	        currentColor.b = pixels[pixelStart + 2];
	        currentColor.a = pixels[pixelStart + 3];

	        if (! stopFunction(seedColor, currentColor)) {
	          // Color the pixel with the fill color. 
	          //ImageProcessing.setColor(pixels, currentX, currentY, boundsWidth, boundsHeight, fillColor);
	          // Inline setColor for performance
	          pixels[pixelStart] = fillRed;
	          pixels[pixelStart + 1] = fillGreen;
	          pixels[pixelStart + 2] = fillBlue;
	          pixels[pixelStart + 3] = fillAlpha;

	          if (minChangedX < currentX) { minChangedX = currentX; }
	          else if (maxChangedX > currentX) { maxChangedX = currentX; }
	          if (minChangedY < currentY) { minChangedY = currentY; }
	          else if (maxChangedY > currentY) { maxChangedY = currentY; }

	          // Add the adjacent four pixels to the list to be tested, unless they have already been tested.
	          tryX = currentX - 1;
	          tryY = currentY;
	          tryIndex = tryY * boundsWidth + tryX;
	          if (tryX >= 0 && ! wasTested[tryIndex]) {
	            shouldTest.push(tryIndex); 
	          }
	          tryX = currentX;
	          tryY = currentY + 1;
	          tryIndex = tryY * boundsWidth + tryX;
	          if (tryY < boundsHeight && ! wasTested[tryIndex]) {
	            shouldTest.push(tryIndex); 
	          }
	          tryX = currentX + 1;
	          tryY = currentY;
	          tryIndex = tryY * boundsWidth + tryX;
	          if (tryX < boundsWidth && ! wasTested[tryIndex]) {
	            shouldTest.push(tryIndex); 
	          }
	          tryX = currentX;
	          tryY = currentY - 1;
	          tryIndex = tryY * boundsWidth + tryX;
	          if (tryY >= 0 && ! wasTested[tryIndex]) {
	            shouldTest.push(tryIndex); 
	          }
	        }
	      }
	    }
	    return imgData;
    }

	function drawCatmull(points, xoffset){
		xoffset = xoffset || 0;
		for(var i = 0; i < points.length-3; i++){
			ctx.beginPath();
			ctx.moveTo(points[i+1][0],points[i+1][1]);
			for(var j=0; j< 50; j++){
				var pi = interpolate(points[i],points[i+1],points[i+2],points[i+3],j/50);
				ctx.lineTo(pi[0] + xoffset ,pi[1]);
			}
			ctx.stroke();
		}
	}

	function makeCatmull(points){
		var _points = [];
		for(var i = 0; i < points.length-3; i++){
			var diff = Math.abs(points[i+1][1] - points[i+2][1]);
			for(var j=0; j< diff; j++){
				var pi = interpolate(points[i],points[i+1],points[i+2],points[i+3],j/diff);
				_points.push([pi[0], pi[1], 0, 0, 0]);
			}
		}
		return _points;
	}

	function makezigzag(points){
		ctx.beginPath();
		ctx.moveTo(points[0][0],points[0][1]);
		for(var i = 0; i < points.length; i++){
			pi = points[i];
			ctx.lineTo(pi[0],pi[1]);
		}
		ctx.stroke();

	}

	function interpolate(P0, P1, P2, P3, u)
	{
		var u3 = u * u * u;
		var u2 = u * u;
		var f1 = -0.5 * u3 + u2 - 0.5 * u;
		var f2 =  1.5 * u3 - 2.5 * u2 + 1.0;
		var f3 = -1.5 * u3 + 2.0 * u2 + 0.5 * u;
		var f4 =  0.5 * u3 - 0.5 * u2;
		var x = P0[0] * f1 + P1[0] * f2 + P2[0] * f3 + P3[0] * f4;
		var y = P0[1] * f1 + P1[1] * f2 + P2[1] * f3 + P3[1] * f4;
		return [x,y];
	}

	function fillEveryPixel(ctx){
		console.log("ping");
		var points = [];
		for(var i = 0 ; i < window.W; i++){
			for(var j = 0 ; j < window.H; j++){
				points.push([i,j,0]);
			}
		}
		ctx.input(points);
	}

	function fillCircles(ctx){
		var points = [];
		for(var i = 0 ; i < window.W; i++){
			for(var j = 0 ; j < window.H; j++){
				if((Math.sqrt(i*i+j*j)|0)%7==1 )points.push([i,j,0]);
			}
		}
		ctx.input(points);
	}

	//http://www.phpied.com/files/canvas/matrix.html

	function convolve(ctx, matrix, divisor, offset) {
	  var m = [].concat(matrix[0], matrix[1], matrix[2]); // flatten
	  if (!divisor) {
	    divisor = m.reduce(function(a, b) {return a + b;}) || 1; // sum
	  }
	  var olddata = ctx.getImageData(0,0,window.W, window.H);
	  var oldpx = olddata.data;
	  var newdata = ctx.createImageData(olddata);
	  var newpx = newdata.data
	  var len = newpx.length;
	  var res = 0;
	  var w = olddata.width;
	  for (var i = 0; i < len; i++) {
	    if ((i + 1) % 4 === 0) {
	      newpx[i] = oldpx[i];
	      continue;
	    }
	    res = 0;
	    var these = [
	      oldpx[i - w * 4 - 4] || oldpx[i],
	      oldpx[i - w * 4]     || oldpx[i],
	      oldpx[i - w * 4 + 4] || oldpx[i],
	      oldpx[i - 4]         || oldpx[i],
	      oldpx[i],
	      oldpx[i + 4]         || oldpx[i],
	      oldpx[i + w * 4 - 4] || oldpx[i],
	      oldpx[i + w * 4]     || oldpx[i],
	      oldpx[i + w * 4 + 4] || oldpx[i]
	    ];
	    for (var j = 0; j < 9; j++) {
	      res += these[j] * m[j];
	    }
	    res /= divisor;
	    if (offset) {
	      res += offset;
	    }
	    newpx[i] = res;
	  }
	  newdata.data = newpx;
	  ctx.putImageData(newdata,0,0);
	};


	//ctx.clear(); makePath(ctx,400,30); for (var i = 0; i < 4; i++) convolve(ctx, [[01,1,01],  [1,-7,1],  [1,1,1]], 7, 200); var asd = ctx.getImageData(0,0,window.W, window.H); for (var ij=0; ij<asd.data.length; ij++) {if (ij%4!=3 && asd.data[ij]==255) asd.data[ij]=0;}; ctx.putImageData(asd,0,0)
	function magix(){
		ctx.clear(); makePath(ctx,400,30); for (var i = 0; i < 4; i++) convolve(ctx, [[01,1,01],  [1,-7,1],  [1,1,1]], 7, 200); var asd = ctx.getImageData(0,0,window.W, window.H); for (var ij=0; ij<asd.data.length; ij++) {if (ij%4!=3 && asd.data[ij]==255) asd.data[ij]=0;}; ctx.putImageData(asd,0,0)
	}

	function magix2(){
		ctx.clear();
		makePath(ctx,(Math.random()*window.W*0.8+window.W*0.1)|0,(Math.random()*window.W*0.8+window.W*0.1)|0);
		for (var i = 0; i < 5; i++) convolve(ctx, [[01,1,01],  [1,-7,1],  [1,1,1]], 8, 200); 
		var imgData = ctx.getImageData(0,0,window.W, window.H);
	 	for (var ij=0; ij<imgData.data.length; ij++) {if (ij%4!=3 && imgData.data[ij]==255) imgData.data[ij]=0;};
		
		var ref = imgData.getPixel(0,0);
		floodFill(imgData,ref,0,0);
		
		ref = imgData.getPixel(window.W-1,window.H-1);
		floodFill(imgData,ref,window.W-1,window.H-1);

		for (var ij=0; ij<imgData.data.length; ij+=4) {
			if(imgData.data[ij]==255) {
				imgData.data[ij]=255;
				imgData.data[ij+1]=255;
				imgData.data[ij+2]=255;
				imgData.data[ij+3]=255;
			} else {
				imgData.data[ij]=0;
				imgData.data[ij+1]=0;
				imgData.data[ij+2]=0;
				imgData.data[ij+3]=255;
			}
		};

		ctx.putImageData(imgData,0,0);
	}

</script>
</body>
</html>